// Code generated by MockGen. DO NOT EDIT.
// Source: shutdown/v2/interfaces.go

// Package v2 is a generated GoMock package.
package v2

import (
	reflect "reflect"

	stop "github.com/ThomasObenaus/go-base/shutdown/v2/stop"
	gomock "github.com/golang/mock/gomock"
)

// MockSynchronizedList is a mock of SynchronizedList interface.
type MockSynchronizedList struct {
	ctrl     *gomock.Controller
	recorder *MockSynchronizedListMockRecorder
}

// MockSynchronizedListMockRecorder is the mock recorder for MockSynchronizedList.
type MockSynchronizedListMockRecorder struct {
	mock *MockSynchronizedList
}

// NewMockSynchronizedList creates a new mock instance.
func NewMockSynchronizedList(ctrl *gomock.Controller) *MockSynchronizedList {
	mock := &MockSynchronizedList{ctrl: ctrl}
	mock.recorder = &MockSynchronizedListMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSynchronizedList) EXPECT() *MockSynchronizedListMockRecorder {
	return m.recorder
}

// AddToBack mocks base method.
func (m *MockSynchronizedList) AddToBack(stoppable1 stop.Stoppable) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddToBack", stoppable1)
}

// AddToBack indicates an expected call of AddToBack.
func (mr *MockSynchronizedListMockRecorder) AddToBack(stoppable1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToBack", reflect.TypeOf((*MockSynchronizedList)(nil).AddToBack), stoppable1)
}

// AddToFront mocks base method.
func (m *MockSynchronizedList) AddToFront(stoppable stop.Stoppable) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddToFront", stoppable)
}

// AddToFront indicates an expected call of AddToFront.
func (mr *MockSynchronizedListMockRecorder) AddToFront(stoppable interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToFront", reflect.TypeOf((*MockSynchronizedList)(nil).AddToFront), stoppable)
}

// GetItems mocks base method.
func (m *MockSynchronizedList) GetItems() []stop.Stoppable {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItems")
	ret0, _ := ret[0].([]stop.Stoppable)
	return ret0
}

// GetItems indicates an expected call of GetItems.
func (mr *MockSynchronizedListMockRecorder) GetItems() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItems", reflect.TypeOf((*MockSynchronizedList)(nil).GetItems))
}

// MockSignalHandler is a mock of SignalHandler interface.
type MockSignalHandler struct {
	ctrl     *gomock.Controller
	recorder *MockSignalHandlerMockRecorder
}

// MockSignalHandlerMockRecorder is the mock recorder for MockSignalHandler.
type MockSignalHandlerMockRecorder struct {
	mock *MockSignalHandler
}

// NewMockSignalHandler creates a new mock instance.
func NewMockSignalHandler(ctrl *gomock.Controller) *MockSignalHandler {
	mock := &MockSignalHandler{ctrl: ctrl}
	mock.recorder = &MockSignalHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSignalHandler) EXPECT() *MockSignalHandlerMockRecorder {
	return m.recorder
}

// StopWaitingAndNotifyListener mocks base method.
func (m *MockSignalHandler) StopWaitingAndNotifyListener() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StopWaitingAndNotifyListener")
}

// StopWaitingAndNotifyListener indicates an expected call of StopWaitingAndNotifyListener.
func (mr *MockSignalHandlerMockRecorder) StopWaitingAndNotifyListener() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopWaitingAndNotifyListener", reflect.TypeOf((*MockSignalHandler)(nil).StopWaitingAndNotifyListener))
}

// WaitForSignal mocks base method.
func (m *MockSignalHandler) WaitForSignal() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitForSignal")
}

// WaitForSignal indicates an expected call of WaitForSignal.
func (mr *MockSignalHandlerMockRecorder) WaitForSignal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForSignal", reflect.TypeOf((*MockSignalHandler)(nil).WaitForSignal))
}

// MockLog is a mock of Log interface.
type MockLog struct {
	ctrl     *gomock.Controller
	recorder *MockLogMockRecorder
}

// MockLogMockRecorder is the mock recorder for MockLog.
type MockLogMockRecorder struct {
	mock *MockLog
}

// NewMockLog creates a new mock instance.
func NewMockLog(ctrl *gomock.Controller) *MockLog {
	mock := &MockLog{ctrl: ctrl}
	mock.recorder = &MockLogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLog) EXPECT() *MockLogMockRecorder {
	return m.recorder
}

// ServiceWasStopped mocks base method.
func (m *MockLog) ServiceWasStopped(name string, err ...error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{name}
	for _, a := range err {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "ServiceWasStopped", varargs...)
}

// ServiceWasStopped indicates an expected call of ServiceWasStopped.
func (mr *MockLogMockRecorder) ServiceWasStopped(name interface{}, err ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name}, err...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServiceWasStopped", reflect.TypeOf((*MockLog)(nil).ServiceWasStopped), varargs...)
}

// ServiceWillBeStopped mocks base method.
func (m *MockLog) ServiceWillBeStopped(name string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ServiceWillBeStopped", name)
}

// ServiceWillBeStopped indicates an expected call of ServiceWillBeStopped.
func (mr *MockLogMockRecorder) ServiceWillBeStopped(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServiceWillBeStopped", reflect.TypeOf((*MockLog)(nil).ServiceWillBeStopped), name)
}

// ShutdownSignalReceived mocks base method.
func (m *MockLog) ShutdownSignalReceived() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ShutdownSignalReceived")
}

// ShutdownSignalReceived indicates an expected call of ShutdownSignalReceived.
func (mr *MockLogMockRecorder) ShutdownSignalReceived() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownSignalReceived", reflect.TypeOf((*MockLog)(nil).ShutdownSignalReceived))
}

// MockHealth is a mock of Health interface.
type MockHealth struct {
	ctrl     *gomock.Controller
	recorder *MockHealthMockRecorder
}

// MockHealthMockRecorder is the mock recorder for MockHealth.
type MockHealthMockRecorder struct {
	mock *MockHealth
}

// NewMockHealth creates a new mock instance.
func NewMockHealth(ctrl *gomock.Controller) *MockHealth {
	mock := &MockHealth{ctrl: ctrl}
	mock.recorder = &MockHealthMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHealth) EXPECT() *MockHealthMockRecorder {
	return m.recorder
}

// IsHealthy mocks base method.
func (m *MockHealth) IsHealthy() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsHealthy")
	ret0, _ := ret[0].(error)
	return ret0
}

// IsHealthy indicates an expected call of IsHealthy.
func (mr *MockHealthMockRecorder) IsHealthy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsHealthy", reflect.TypeOf((*MockHealth)(nil).IsHealthy))
}

// ShutdownSignalReceived mocks base method.
func (m *MockHealth) ShutdownSignalReceived() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ShutdownSignalReceived")
}

// ShutdownSignalReceived indicates an expected call of ShutdownSignalReceived.
func (mr *MockHealthMockRecorder) ShutdownSignalReceived() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownSignalReceived", reflect.TypeOf((*MockHealth)(nil).ShutdownSignalReceived))
}

// String mocks base method.
func (m *MockHealth) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockHealthMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockHealth)(nil).String))
}
