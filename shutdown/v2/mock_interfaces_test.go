// Code generated by MockGen. DO NOT EDIT.
// Source: shutdown/v2/interfaces.go

// Package v2 is a generated GoMock package.
package v2

import (
	reflect "reflect"

	stop "github.com/ThomasObenaus/go-base/shutdown/v2/stop"
	gomock "github.com/golang/mock/gomock"
)

// MocksynchronizedList is a mock of synchronizedList interface.
type MocksynchronizedList struct {
	ctrl     *gomock.Controller
	recorder *MocksynchronizedListMockRecorder
}

// MocksynchronizedListMockRecorder is the mock recorder for MocksynchronizedList.
type MocksynchronizedListMockRecorder struct {
	mock *MocksynchronizedList
}

// NewMocksynchronizedList creates a new mock instance.
func NewMocksynchronizedList(ctrl *gomock.Controller) *MocksynchronizedList {
	mock := &MocksynchronizedList{ctrl: ctrl}
	mock.recorder = &MocksynchronizedListMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksynchronizedList) EXPECT() *MocksynchronizedListMockRecorder {
	return m.recorder
}

// AddToBack mocks base method.
func (m *MocksynchronizedList) AddToBack(stoppable1 stop.Stoppable) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddToBack", stoppable1)
}

// AddToBack indicates an expected call of AddToBack.
func (mr *MocksynchronizedListMockRecorder) AddToBack(stoppable1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToBack", reflect.TypeOf((*MocksynchronizedList)(nil).AddToBack), stoppable1)
}

// AddToFront mocks base method.
func (m *MocksynchronizedList) AddToFront(stoppable stop.Stoppable) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddToFront", stoppable)
}

// AddToFront indicates an expected call of AddToFront.
func (mr *MocksynchronizedListMockRecorder) AddToFront(stoppable interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToFront", reflect.TypeOf((*MocksynchronizedList)(nil).AddToFront), stoppable)
}

// GetItems mocks base method.
func (m *MocksynchronizedList) GetItems() []stop.Stoppable {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetItems")
	ret0, _ := ret[0].([]stop.Stoppable)
	return ret0
}

// GetItems indicates an expected call of GetItems.
func (mr *MocksynchronizedListMockRecorder) GetItems() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItems", reflect.TypeOf((*MocksynchronizedList)(nil).GetItems))
}

// MocksignalHandler is a mock of signalHandler interface.
type MocksignalHandler struct {
	ctrl     *gomock.Controller
	recorder *MocksignalHandlerMockRecorder
}

// MocksignalHandlerMockRecorder is the mock recorder for MocksignalHandler.
type MocksignalHandlerMockRecorder struct {
	mock *MocksignalHandler
}

// NewMocksignalHandler creates a new mock instance.
func NewMocksignalHandler(ctrl *gomock.Controller) *MocksignalHandler {
	mock := &MocksignalHandler{ctrl: ctrl}
	mock.recorder = &MocksignalHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksignalHandler) EXPECT() *MocksignalHandlerMockRecorder {
	return m.recorder
}

// StopWaitingAndNotifyListener mocks base method.
func (m *MocksignalHandler) StopWaitingAndNotifyListener() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StopWaitingAndNotifyListener")
}

// StopWaitingAndNotifyListener indicates an expected call of StopWaitingAndNotifyListener.
func (mr *MocksignalHandlerMockRecorder) StopWaitingAndNotifyListener() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopWaitingAndNotifyListener", reflect.TypeOf((*MocksignalHandler)(nil).StopWaitingAndNotifyListener))
}

// WaitForSignal mocks base method.
func (m *MocksignalHandler) WaitForSignal() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitForSignal")
}

// WaitForSignal indicates an expected call of WaitForSignal.
func (mr *MocksignalHandlerMockRecorder) WaitForSignal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForSignal", reflect.TypeOf((*MocksignalHandler)(nil).WaitForSignal))
}

// Mocklog is a mock of log interface.
type Mocklog struct {
	ctrl     *gomock.Controller
	recorder *MocklogMockRecorder
}

// MocklogMockRecorder is the mock recorder for Mocklog.
type MocklogMockRecorder struct {
	mock *Mocklog
}

// NewMocklog creates a new mock instance.
func NewMocklog(ctrl *gomock.Controller) *Mocklog {
	mock := &Mocklog{ctrl: ctrl}
	mock.recorder = &MocklogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocklog) EXPECT() *MocklogMockRecorder {
	return m.recorder
}

// ServiceWasStopped mocks base method.
func (m *Mocklog) ServiceWasStopped(name string, err ...error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{name}
	for _, a := range err {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "ServiceWasStopped", varargs...)
}

// ServiceWasStopped indicates an expected call of ServiceWasStopped.
func (mr *MocklogMockRecorder) ServiceWasStopped(name interface{}, err ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name}, err...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServiceWasStopped", reflect.TypeOf((*Mocklog)(nil).ServiceWasStopped), varargs...)
}

// ServiceWillBeStopped mocks base method.
func (m *Mocklog) ServiceWillBeStopped(name string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ServiceWillBeStopped", name)
}

// ServiceWillBeStopped indicates an expected call of ServiceWillBeStopped.
func (mr *MocklogMockRecorder) ServiceWillBeStopped(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServiceWillBeStopped", reflect.TypeOf((*Mocklog)(nil).ServiceWillBeStopped), name)
}

// ShutdownSignalReceived mocks base method.
func (m *Mocklog) ShutdownSignalReceived() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ShutdownSignalReceived")
}

// ShutdownSignalReceived indicates an expected call of ShutdownSignalReceived.
func (mr *MocklogMockRecorder) ShutdownSignalReceived() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownSignalReceived", reflect.TypeOf((*Mocklog)(nil).ShutdownSignalReceived))
}

// Mockhealth is a mock of health interface.
type Mockhealth struct {
	ctrl     *gomock.Controller
	recorder *MockhealthMockRecorder
}

// MockhealthMockRecorder is the mock recorder for Mockhealth.
type MockhealthMockRecorder struct {
	mock *Mockhealth
}

// NewMockhealth creates a new mock instance.
func NewMockhealth(ctrl *gomock.Controller) *Mockhealth {
	mock := &Mockhealth{ctrl: ctrl}
	mock.recorder = &MockhealthMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockhealth) EXPECT() *MockhealthMockRecorder {
	return m.recorder
}

// IsHealthy mocks base method.
func (m *Mockhealth) IsHealthy() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsHealthy")
	ret0, _ := ret[0].(error)
	return ret0
}

// IsHealthy indicates an expected call of IsHealthy.
func (mr *MockhealthMockRecorder) IsHealthy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsHealthy", reflect.TypeOf((*Mockhealth)(nil).IsHealthy))
}

// ShutdownSignalReceived mocks base method.
func (m *Mockhealth) ShutdownSignalReceived() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ShutdownSignalReceived")
}

// ShutdownSignalReceived indicates an expected call of ShutdownSignalReceived.
func (mr *MockhealthMockRecorder) ShutdownSignalReceived() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownSignalReceived", reflect.TypeOf((*Mockhealth)(nil).ShutdownSignalReceived))
}

// String mocks base method.
func (m *Mockhealth) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockhealthMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*Mockhealth)(nil).String))
}
