// Code generated by MockGen. DO NOT EDIT.
// Source: shutdown/interfaces.go

// Package shutdown is a generated GoMock package.
package shutdown

import (
	reflect "reflect"

	stop "github.com/ThomasObenaus/go-base/shutdown/stop"
	gomock "github.com/golang/mock/gomock"
	zerolog "github.com/rs/zerolog"
)

// MockstopIF is a mock of stopIF interface.
type MockstopIF struct {
	ctrl     *gomock.Controller
	recorder *MockstopIFMockRecorder
}

// MockstopIFMockRecorder is the mock recorder for MockstopIF.
type MockstopIFMockRecorder struct {
	mock *MockstopIF
}

// NewMockstopIF creates a new mock instance.
func NewMockstopIF(ctrl *gomock.Controller) *MockstopIF {
	mock := &MockstopIF{ctrl: ctrl}
	mock.recorder = &MockstopIFMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockstopIF) EXPECT() *MockstopIFMockRecorder {
	return m.recorder
}

// AddToBack mocks base method.
func (m *MockstopIF) AddToBack(stoppable1 stop.Stoppable) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToBack", stoppable1)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToBack indicates an expected call of AddToBack.
func (mr *MockstopIFMockRecorder) AddToBack(stoppable1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToBack", reflect.TypeOf((*MockstopIF)(nil).AddToBack), stoppable1)
}

// AddToFront mocks base method.
func (m *MockstopIF) AddToFront(stoppable stop.Stoppable) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToFront", stoppable)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToFront indicates an expected call of AddToFront.
func (mr *MockstopIFMockRecorder) AddToFront(stoppable interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToFront", reflect.TypeOf((*MockstopIF)(nil).AddToFront), stoppable)
}

// StopAllInOrder mocks base method.
func (m *MockstopIF) StopAllInOrder(logger zerolog.Logger) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StopAllInOrder", logger)
}

// StopAllInOrder indicates an expected call of StopAllInOrder.
func (mr *MockstopIFMockRecorder) StopAllInOrder(logger interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopAllInOrder", reflect.TypeOf((*MockstopIF)(nil).StopAllInOrder), logger)
}

// MocksignalHandlerIF is a mock of signalHandlerIF interface.
type MocksignalHandlerIF struct {
	ctrl     *gomock.Controller
	recorder *MocksignalHandlerIFMockRecorder
}

// MocksignalHandlerIFMockRecorder is the mock recorder for MocksignalHandlerIF.
type MocksignalHandlerIFMockRecorder struct {
	mock *MocksignalHandlerIF
}

// NewMocksignalHandlerIF creates a new mock instance.
func NewMocksignalHandlerIF(ctrl *gomock.Controller) *MocksignalHandlerIF {
	mock := &MocksignalHandlerIF{ctrl: ctrl}
	mock.recorder = &MocksignalHandlerIFMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksignalHandlerIF) EXPECT() *MocksignalHandlerIFMockRecorder {
	return m.recorder
}

// NotifyListenerAndStopWaiting mocks base method.
func (m *MocksignalHandlerIF) NotifyListenerAndStopWaiting() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NotifyListenerAndStopWaiting")
}

// NotifyListenerAndStopWaiting indicates an expected call of NotifyListenerAndStopWaiting.
func (mr *MocksignalHandlerIFMockRecorder) NotifyListenerAndStopWaiting() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotifyListenerAndStopWaiting", reflect.TypeOf((*MocksignalHandlerIF)(nil).NotifyListenerAndStopWaiting))
}

// WaitForSignal mocks base method.
func (m *MocksignalHandlerIF) WaitForSignal() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitForSignal")
}

// WaitForSignal indicates an expected call of WaitForSignal.
func (mr *MocksignalHandlerIFMockRecorder) WaitForSignal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForSignal", reflect.TypeOf((*MocksignalHandlerIF)(nil).WaitForSignal))
}
